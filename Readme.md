# Python Trial [Tic - Tac - Toe]

### Структура тріалу
1. Вступне відео
    1. Відео
    2. Знайомство з викладачем. Що таке мова програмування? Чим Python особливий? Хто використовує Python на ринку та для яких задач. Постановка задачі хрестики нолики.
2. Встановлюємо Python та налаштовуємо середовище для розробки VScode 
    1. Відео
    2. У цьому відео ми розглянемо особливості встановлення пайтону на різні операційні системи, а також поговоримо про різні опції для середовища розробки. Огляд функціоналу VScode.
3. Авточек 1
4. Змінні та типи даних.
    1. Відео
    2. Поговоримо про те, на які види поділяють інформацію у Python та як зберегти щось у памʼятті. Які типи даних потрібно використати для хрестиків ноликів.
5. Авточек 2
6. Авточек 3
7. Форматування рядка, спеціальні символи.
    1. Відео
    2. Розберемо детальніше роботу з рядками, зокрема як динамічно формувати повідомлення про те, який символ переміг у грі.
8. Авточек 4
9. Авточек 5
10. Ввід даних та приведення типів
    1. Відео
    2. Що робити у випадку, коли ми очікуємо від користувача одні дані, напр. текст, а отримуємо число? Як безпечно обробляти ввід користувача.
11. Авточек 6
12. Авточек 7
13. Умовне виконання
    1. Відео
    2. У цьому відео поговоримо про те, як у програмуванні працює механізм умовного виконання. Як програма визначає, який символ гравця? 
14. Авточек 8
15. Авточек 9
16. Методи рядка
    1. Відео
    2. У цьому відео розглянемо деякі методи рядка та як зробити меню регістронезалежним.
17. Авточек 10
18. Авточек 11
19. Індексація
    1. Відео
    2. Розглянемо роботу з вкладеним (двовимірним) списком та індексацію, зокрема механізм зрізів для роботи з ігровим полем.
20. Авточек 12
21. Авточек 13
22. Цикл for
    1. Відео
    2. Як виконувати ту саму інструкцію скільки завгодно разів. Як перебрати усі елементи колекції. Як перевірити усі рядки та стовпці на наявність переможця?
23. Авточек 14
24. Авточек 15
25. Цикл while
    1. Відео
    2. Дивно було б грати в гру, що закривається щойно ми її відкрили, правда ж? У цьому відео розглянемо альтернативу циклу for та створимо інтерактивне меню за допомогою вічного циклу.
26. Авточек 16
27. Обробка винятків
    1. Відео
    2. У цьому відео поговоримо про ситуації, коли програма може зупинити виконання достроково. Розглянемо винятки та способи їх обробки, зокрема коли гравець вводить довільний символ замість `X` чи `O`.
28. Авточек 17
29. Авточек 18
30. Функції.
    1. Відео
    2. Поговоримо про те, чому важливо розбивати код на функції та які переваги це надає. Розбиваємо гру на концептуальні блоки.
31. Авточек 19
32. Авточек 20
33. Збираємо проект
    1. Відео
    2. У цьому відео поєднаємо усі компоненти у повноцінну гру хрестики нолики, проведемо тестування.
34. Квіз
35. Підбиття підсумків

### Cписок авточеків
1. Запуск інтерпретатора та вивід у консоль
    1. Опис: Виведіть у консоль повідомлення "Let's play tic-tac-toe".  Памʼятайте, що текст необхідно вказувати у лапках.
    2. ```
        print("Let's play tic-tac-toe")
        ```
2. Змінні та типи даних
    1. Опис: Кожна змінна у Python зберігається в оперативній пам'яті компʼютера. Створіть змінну `sign` (тип string) зі значенням `X` та виведіть у консоль адресу памʼяті цієї змінної. Підказка: використовуйте вбудовану функцію.
    2. ```
        sign="X"
        print(id(sign))
        ```
3. Змінні та типи даних
    1. Опис: Для зберігання символів у хрестиках ноликах зручно використовувати словник, де ключі це цифри 1, 2, а значення "X", "O" відповідно. Створіть такий словник.
    2. ```
        SIGNS = {
            1: "X",
            2: "O"
        }
        ```
4. Форматування рядка
    1. Опис: Кожна гра потребує детального меню з усіма можливими опціми для користувача. Створіть змінну типу string `MENU`, що містить 2 рядки тексту. Перший рядок: `Hello! Welcome to Tic Tac Toe game!`, Другий рядок: `Rules: X and O takes turns marking the spaces in a 3*3 grid`.
    Підказка: використовуйте функцію `print` лише один раз.
    2. ```
        MENU = """
        Hello! Welcome to Tic Tac Toe game!
        Rules: X and O takes turns marking the spaces in a 3*3 grid
        """
        ```
5. Форматування рядка
    1. Опис: Для того, щоб повідомити користувачеві про перемогу, необхідно сформувати рядок із символом, що переміг. Створіть змінну `player` (тип string) зі значення `X`. Використовуючи змінну `player` cтворіть змінну `PLAYER_WON_MESSAGE` у форматі `Player <символ переможця>, you won!` та виведіть її у консоль. Підказка: символи `<>` виключно для позначення меж тексту. Їх виводити не потрібно
    2. ```
        player = "X"
        PLAYER_WON_MESSAGE = f"Player {player}, you won!"
        ```
6. Ввід даних
    1. Опис: Попросіть користувача обрати символ для гри: `X` або `Y`, використовуючи повідомлення `Please enter your sign >>> `. Створіть змінну `sign` та виведіть у консоль повідомлення `Player <символ>, your turn!`.
    2. ```
        sign = input("Please enter your sign >>> ")
        print(f"Player {sign}, your turn!")
        ```
7. Приведення типів
    1. Опис: Вбудована функція `input` повертає будь-який ввід користувача як тип `str`. Попросіть користувача обрати символ за допомогою цифри, щоб уникнути помилок (напр. введено не той символ або з малої літери). Створіть змінну `choice` на основі вводу користувача. Повідомлення для вводу `Player 1, what's your sign? [choose 1:X or 2:O] >>> `. Приведіть `choice` до типу `int` та виведіть у консоль, чи число є парним. На основі парності числа можна визначати, який гравець зараз ходить.
    2. ```
        choice = int(input("Player 1, what's your sign? [choose 1:X or 2:O] >>> "))
        print(choice % 2 == 0)
        ```

8. Конструкція if-else
    1. Опис: Гра закінчується тоді, коли є переможець або використано усі можливі клітинки. Створіть змінні `has_winner` та `count` із значеннями `True` та `9` відповідно. Виведіть у консоль повідомлення `Game is over!` за умови, шо є переможець або усі комірки використані (усього їх `9`).
    2. ```
        has_winner = True
        count = 9
        if has_winner or count == 9:
            print("Game is over")
        ```
9. Конструкція if-else
    1. Опис: Оскільки хрестики-нолики це гра для двох потрібно визначити, хто ким грає. Створіть змінну `choice` на основі вводу користувача. Повідомлення для вводу `Player 1, what's your sign? [choose 1:X or 2:O] >>> `. Приведіть `choice` до типу `int`. Створіть змінні `player1` та `player2`, запишіть у них значення `X` або `O` в залежності від вибору користувача. Напр. якщо користувач обрав `1`, то `player1="X"`, а `player2="O"` і навпаки у випадку, коли користувач обрав `2`. Якщо користувач ввів не 1 чи 2 виведіть повідомлення `Not an option`.
    2. ```
        choice = int(input("Player 1, what's your sign? [choose 1:X or 2:O] >>> "))
            
        if choice == 1:
            player1 = "X"
            player2 = "O"
        elif choice == 2:
            player1 = "O"
            player2 = "X"
        else:
            print("Not an option")

        ```
10. Методи рядка
    1. Опис: Вибір у меню не повинен залежати від регістру введеної літери. Створіть змінну `choice` для збереження вводу користувача. Текст при вводі `Choose [b] to print the board >>> `. Якщо користувач введе `b` або `B` виведіть змінну `BOARD`. Підказка: використовуйте метод `lower`.
    2. ```
        BOARD = [["O", "O", "X"],
                ["O", "X", "O"],
                ["X", "X", "X"]]
        choice = input("Choose [b] to print the board >>> ")
        if choice.lower() == "b":
            print(BOARD)
        ```
11. Методи рядка
    1. Опис: Створіть змінну `choice` для збереження вводу користувача. Текст при вводі `Choose [1-9] to pick the cell >>> `. Якщо користувач введе цифру виведіть `Cell #<номер> selected` у консоль.
    2. ```
        choice = input("Choose [1-9] to pick the cell >>> ")
        if choice.isdigit():
            print(f"Cell #{choice} selected")
        ```
12. Вкладений список
    1. Опис: Важко уявити гру хрестики нолики без дошки для гри. Для цієї задачі чудово підходить вкладений список. Дошка для гри містить 3*3 = 9 клітинок. Створіть змінну `BOARD` (тип `list`), де кожен рядок це окремий список. Використовуйте порожній рядок для кожної клітинки як значення.
    2. ```
        BOARD = [["", "", ""],
                ["", "", ""],
                ["", "", ""]]
        ```
13. Вкладений список
    1. Опис: Перевірте, чи є переможець на головній діагоналі. Створіть змінні `player1` та `player2` зі значеннями `X` та `O` відповідно. Якщо переміг `player1` виведіть повідомлення `Player 1 won!`. Якщо переміг `player2` виведіть повідомлення `Player 2 won!`. Якщо переможця на діагоналі немає виведіть `"Game continue"`. Підказка: використовуйте конструкцію if-elif-else. Для умови перевірте, чи елементи на на діагоналі співпадають із символом гравця.
    2. ```
        BOARD = [["X", " ", " "],
                [" ", "X", " "],
                [" ", " ", "O"]]
        player1 = "X"
        player2 = "O"

        if BOARD[0][0] == BOARD[1][1] == BOARD[2][2] == player1:
            print("Player 1 won!")
        elif BOARD[0][0] == BOARD[1][1] == BOARD[2][2] == player2:
            print("Player 2 won!")
        else:
            print("Game continue")
        ```
14. Цикл for.
    1. Для зручності користувача нам необхідно промаркувати кожну позицію на дошці. Створіть змінну `POSITIONS` типу `dict` та збережіть у ній усі можливі комбінації клітинок, де ключ це цифра від `1` до `9`, а значення коодината у форматі `(row[0-2], column[0-2])` типу `tuple`. Напр. `1: (0, 0)` означає клітинка `1`, рядок `0` та стовпець `0`; `5: (1, 1)` означає клітинка `5`, рядок `1` та стовпець `1`, а `9: (2, 2)` означає клітинка `9`, рядок `2` та стовпець `2`. Виведіть у консоль усі комбінації у форматі `Cell #<номер клітинки>: <координата>`.
    2. ```
        POSITIONS = {
            1: (0, 0),
            2: (0, 1),
            3: (0, 2),
            4: (1, 0),
            5: (1, 1),
            6: (1, 2),
            7: (2, 0),
            8: (2, 1),
            9: (2, 2),
        }
        for cell, coordinates in POSITIONS.items():
            print(f"Cell #{cell}: {coordinates}")
        ```
15. Цикл for.
    1. Створіть змінну `player` із значення `X` та перевірте, чи переміг він в одному з трьох рядків. Назвіть змінну циклу `row`. У випадку перемоги виведіть повідомлення у форматі `Match in row #<row>`. Підказка: для цієї задачі необхідно перебрати 3 рядки за допомогою циклу та використати конструкцію `if`. Для умови перевірте, чи елементи у поточному рядку співпадають із символом гравця.
    2. ```
        BOARD = [["O", "O", "X"],
                ["O", "X", "O"],
                ["X", "X", "X"]]
        player = "X"
        
        for row in range(3):
            if (BOARD[i][0] == BOARD[i][1] == BOARD[i][2] == player):
                print(f"Match in row #{row}")
        ```
16. Цикл while:
    1. Створіть інтерактивне меню із трьома можливими опціями, що зберігаються у змінну `choice`. Пояснення для користувача стосовно вводу містить наступний текст: `Use [p] for positions, [1-9] for cells and [e] for exit >>> `. Якщо користувач ввів цифру, то виведіть повідомлення `Cell #<номер клітинки> selected`. Якщо користувач ввів літеру `p`, виведіть у консоль розмітку дошки `PATTERN`. Якщо користувач ввів `e`, цикл зупинено. Підказка: валідацію вводу та приведення типу додавати не потрібно. Використовуйте вічний цикл. Для того, щоб розпізнати цифру можете скористатися методом `isdigit`.
    2. ```
        PATTERN =  """ 
                 1 | 2 | 3 
                ---+---+---
                 4 | 5 | 6  
                ---+---+---
                 7 | 8 | 9 
                """
        while True:
            choice = input("Use [p] for positions, [1-9] for cells and [e] for board >>> ")
            if choice.isdigit():
                print(f"Cell #{choice} selected`)
            elif choice == "p":
                print(PATTERN)
            elif choice == "e":
                break
        ```
17. Обробка винятків
    1. Опис: Попри підказки користувач може все ще ввести будь-які дані у консоль. Створіть змінну `choice` для збереження вводу користувача. Текст при вводі `Choose [1-9] to pick the cell >>> `. Приведіть змінну `choice` до типу `int`. Врахуйте, що у випадку, коли користувач введе текст у консоль, виникне `ValueError`. Обробіть цю помилку та у разі її виникнення виведіть повідомлення `Not an option`.
    2. ```
        try:
            choice = int(input("Choose [1-9] to pick the cell >>> "))
        except ValueError:
            print("Not an option")
        ```
18. Обробка винятків
    1. Опис: А що робити у випадку, коли користувач ввів цифру, але не в межах `1-9`? Важко обрати клітинку `999` або `10` при `9` можливих у хрестиках ноликах. Створіть змінну `choice` для збереження вводу користувача. Текст при вводі `Choose [1-9] to pick the cell >>> `. Приведіть змінну `choice` до типу `int`. Врахуйте, що у випадку, коли користувач введе текст у консоль, виникне `ValueError`. Обробіть цю помилку та у разі її виникнення виведіть повідомлення `Not an option`. Якщо користувач обере цифру не з проміжку `1-9` зініціюйте помилку `ValueError`. Підказка: Використовуйте ключове слово `raise`.
    2. ```
        try:
            choice = int(input("Choose [1-9] to pick the cell >>> "))
            if choice < 1 or choice > 9:
                raise ValueError
        except ValueError:
            print("Not an option")
        ```
19. Функції
    1. Опис: Оголосіть функцію `check_diagonal`. Функція приймає параметр `player` (значення `X` або `O`) та перевіряє, чи є перемога по головній діагоналі для зазначеного гравця. Функція повертає `True`, якщо гравець переміг. В іншому випадку - `False`. Підказка: використовуйте ключове слово `return` щоб повернути результат функції.
    2. ```
        BOARD = [["X", "O", "X"],
                ["O", "X", "O"],
                ["X", "X", "X"]]

        def check_diagonal(player):
            res = False
            if BOARD[0][0] == BOARD[1][1] == BOARD[2][2] == player:
                res = True
            return res
        ```
20. Функції
    1. Опис: Оголосіть функцію `update_board`. Функція приймає параметри `row` (тип int), `column` (тип int) та `player` (значення `X` або `O`) та записує значення в конкретну комірку дошки `BOARD`. Функція нічого не повертає. 
    2. ```
        BOARD = [["", "", ""],
                ["", "", ""],
                ["", "", ""]]
        
        def update_board(row, column, player):
            BOARD[row][column] = player

        ```

### Квіз
1. Яка з наведених нижче функцій дозволяє вивести текст у консоль?
    1. `print "Hello, World!"`
    2. `console.log("Hello, World!")`
    3. `print("Hello, World!")` +
    4. `printf("Hello, World!")`
2. За допомогою якого зарезервованого слова можна зупинити виконання циклу?
    1. `continue`
    2. `raise`
    3. `exit`
    4. `break` +
3. `BOARD` це двовимірний масив розмірністю 3x3. Як отримати елемент у 3 рядку та 3 стовпці?
    1. `BOARD[2][2]` +
    2. `BOARD[3]`
    3. `BOARD[3][3]`
    4. `BOARD[0][0]`
4. Як називається програма, що виконує Python код?
    1. `Асемблер`
    2. `Garbage collector`
    3. `Initializator`
    4. `Interpretator` +
5. Коли викликається блок `except` у конструкції `try/except`?
    1. `Коли помилки не відбулося`
    2. `Коли помилка відбулася` +
    3. `Завжди`
    4. `Ніколи`
6. Який тип даних зберігає дані у форматі ключ-значення?
    1. `list`
    2. `dict` +
    3. `tuple`
    4. `str`
7. Чи можна створити вічний цикл за допомогою конструкції for?
    1. `Так`
    2. `Ні` + 
8. Яку проблему вирішують функції?
    1. `Пришвидшують виконання програми`
    2. `Зменшують використання памʼяті`
    3. `Роблять код більш читабельним та без дубляжу` +
    4. `Оголошення власних типів`
9. Який метод дозволяє отримати і ключі, і значення у словнику?
    1. `.items()` +
    2. `.values()`
    3. `.keys()`
    4. `.pairs()`
10. Яка помилка виникне під час приведення типу `int("hello")`?
    1. `KeyError`
    2. `TypeError`
    3. `DoesNotExistError`
    4. `ValueError` +
